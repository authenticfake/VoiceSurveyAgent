.venv) a.franco@AMAFRH96CL7RW VoiceSurveyAgent % PYTHONPATH="runs/kit/REQ-008/src:src" pytest -n auto runs/kit/REQ-008/test -q

bringing up nodes...
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE                                                                                                                                                    [100%]
========================================================================================= ERRORS ==========================================================================================
_______________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_selects_pending_contacts _______________________________________________________
[gw0] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x104429600>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('91617239-3580-41a7-b782-123bd4f9684b'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1045cb710>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10448b9e0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1049a7620>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1049a6a80>, parameters = [(UUID('91617239-3580-41a7-b782-123bd4f9684b'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1044dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10459ecc0>
test_user = <User(id=cd80d6e2-7d12-4016-a917-1e2f93a0ece0, email=tester-971e4f7d-409b-4ba5-812c-781ddc1537d7@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1044dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('91617239-3580-41a7-b782-123bd4f9684b'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_____________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_creates_call_attempt_record ______________________________________________________
[gw4] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1208b5d20>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('ba97c3b0-5ec5-47d3-a436-741a7b974dd3'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1205cf260>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x12048b890>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1208a74a0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1208a6900>, parameters = [(UUID('ba97c3b0-5ec5-47d3-a436-741a7b974dd3'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1204dbc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x12059f860>
test_user = <User(id=04d02b67-4573-485f-bbd8-0dd90b7076d0, email=tester-e8fb0761-258c-463b-8790-83451b6aae09@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1204dbc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('ba97c3b0-5ec5-47d3-a436-741a7b974dd3'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_updates_contact_state_to_in_progress _________________________________________________
[gw5] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1072b1f00>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('3572acbc-4fba-49ab-8d0c-4ea8d4838d2b'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x107264d70>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x106e8b9e0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1072a7440>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1072a68a0>, parameters = [(UUID('3572acbc-4fba-49ab-8d0c-4ea8d4838d2b'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x106edbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106f9fe90>
test_user = <User(id=985230c8-77bf-4983-a4c9-512e6cce5f63, email=tester-086e1599-1a0b-473d-9270-b2f357104d47@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x106edbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('3572acbc-4fba-49ab-8d0c-4ea8d4838d2b'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_____________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_selects_not_reached_contacts _____________________________________________________
[gw1] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x111eb1ea0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('b3c48de5-b931-454a-aead-d5d8654dda9e'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x111ace540>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x11198b950>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x111ea72f0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x111ea6750>, parameters = [(UUID('b3c48de5-b931-454a-aead-d5d8654dda9e'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1119dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x111a9fc80>
test_user = <User(id=6ed9cc47-0204-4d2f-846d-fb4bffb6af58, email=tester-1415895b-fd0e-4a8c-b021-0647507e83be@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1119dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('b3c48de5-b931-454a-aead-d5d8654dda9e'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
____________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_excludes_do_not_call_contacts _____________________________________________________
[gw2] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1112b9ae0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('37bb794a-1bb4-4500-8390-818a9475166e'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x110fcf200>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x110f41220>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1112ab3e0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1112aa840>, parameters = [(UUID('37bb794a-1bb4-4500-8390-818a9475166e'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x110edbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x110e8b6e0>
test_user = <User(id=e9c0bea3-e060-494a-98e6-a829ffbdfa56, email=tester-8b2b6133-5564-4c14-af4f-ecc85df00b0f@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x110edbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('37bb794a-1bb4-4500-8390-818a9475166e'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
______________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_skips_outside_call_window _______________________________________________________
[gw8] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1106b9ba0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('53889df0-ece4-45e0-9e50-fddfcc66e9b0'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x110678c50>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x1102fb830>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1106a7320>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1106a6780>, parameters = [(UUID('53889df0-ece4-45e0-9e50-fddfcc66e9b0'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1102dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x11028b230>
test_user = <User(id=3c05699b-c18c-4ca9-85f8-d0099461d27b, email=tester-015fb47f-e036-48ef-b8ac-644612568f5e@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1102dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('53889df0-ece4-45e0-9e50-fddfcc66e9b0'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_______________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_handles_provider_failure _______________________________________________________
[gw9] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1187cdde0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('8f35c87d-e73a-4576-b6a8-65970145619a'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1066d3050>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x1182a4320>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1187c7500>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1187c6960>, parameters = [(UUID('8f35c87d-e73a-4576-b6a8-65970145619a'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1182dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1183a3da0>
test_user = <User(id=f2678cfa-6ab3-48b7-b16a-fcc9b007b5bd, email=tester-2cf9b86c-5ef0-4071-a2a1-983d8f07e44d@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1182dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('8f35c87d-e73a-4576-b6a8-65970145619a'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
____________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_respects_max_concurrent_calls _____________________________________________________
[gw6] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x107429b40>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('909a6e14-339b-46fa-9d35-d844c0d60524'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x107864da0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10748bb00>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1078a7470>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1078a68d0>, parameters = [(UUID('909a6e14-339b-46fa-9d35-d844c0d60524'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1074dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10759fec0>
test_user = <User(id=1fbbf706-13f7-44c5-be7f-2ec99034c33c, email=tester-aacf74b1-f4e9-4657-9ffc-396a2d2acd9c@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1074dbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('909a6e14-339b-46fa-9d35-d844c0d60524'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
____________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_excludes_max_attempts_contacts ____________________________________________________
[gw3] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1069b1c60>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('5c49f4fd-6778-4ef7-a0a5-4ad732f7cd48'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1066cf530>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10658bb30>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1069a74d0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1069a6930>, parameters = [(UUID('5c49f4fd-6778-4ef7-a0a5-4ad732f7cd48'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1065dbc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10658b890>
test_user = <User(id=48f20e0d-d87c-43c4-b6e7-4782d679806c, email=tester-dbddd514-2d34-4ab9-a256-205daa515430@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1065dbc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('5c49f4fd-6778-4ef7-a0a5-4ad732f7cd48'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
________________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_skips_paused_campaigns ________________________________________________________
[gw7] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1184b1f00>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('7d5d945a-c11b-493d-bee8-f75ab45d3c48'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1180cf6e0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x1180754f0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1184a7470>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1184a68d0>, parameters = [(UUID('7d5d945a-c11b-493d-bee8-f75ab45d3c48'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x107fdbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x11809e8a0>
test_user = <User(id=2331c3d4-9cd0-41aa-8d80-7525737fa371, email=tester-99af1833-ed81-4695-b2a8-d53f3fbeb8cc@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x107fdbd40>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('7d5d945a-c11b-493d-bee8-f75ab45d3c48'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
____________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_creates_call_attempt_record ____________________________________________________
[gw4] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1205c3c40>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x12048b5f0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x12048b890>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x120864950>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x120867620>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1204dbc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1204dbc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
___________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_selects_not_reached_contacts ____________________________________________________
[gw1] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x111e7cd60>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x11198b1a0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x11198b950>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x111e78b90>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x111e78950>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1119dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1119dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
___________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_respects_max_concurrent_calls ___________________________________________________
[gw6] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1071e3dc0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x10748b680>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10748bb00>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x107865160>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x107864980>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1074dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1074dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_______________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_updates_contact_state_to_in_progress ________________________________________________
[gw5] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x10727cd60>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x106e8b620>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x106e8b9e0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x107264bf0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1072670b0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x106edbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x106edbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_____________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_selects_pending_contacts ______________________________________________________
[gw0] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1041e3dc0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x104933920>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10448b9e0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x104965250>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x104965310>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1044dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1044dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_____________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_skips_outside_call_window _____________________________________________________
[gw8] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1106809a0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x110289460>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x1102fb830>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x110678ad0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x11067afc0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1102dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1102dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_____________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_handles_provider_failure ______________________________________________________
[gw9] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x118798ca0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x118247ce0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x1182a4320>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x11877cce0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x11877f680>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1182dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1182dbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
___________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_excludes_do_not_call_contacts ___________________________________________________
[gw2] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1112808e0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x110e8b1d0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x110f41220>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x111264e30>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1112677d0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x110edbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x110edbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
______________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_skips_paused_campaigns _______________________________________________________
[gw7] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x107ce3dc0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x107f8b740>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x1180754f0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x118464950>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1184675f0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x107fdbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x107fdbd40>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
__________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_excludes_max_attempts_contacts ___________________________________________________
[gw3] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x106528700>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x10658b3b0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10658bb30>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x106964ce0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x106964a70>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1065dbc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x1065dbc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_____________________________________________________________ ERROR at setup of TestCallAttemptRepository.test_update_outcome _____________________________________________________________
[gw4] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1217c7940>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('fef6b3e2-95b5-4c79-b78c-cf58917a8bf1'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1217cba70>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x12091fc20>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1217e17f0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x1217e13a0>, parameters = [(UUID('fef6b3e2-95b5-4c79-b78c-cf58917a8bf1'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x12084fb60>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x12091cce0>
test_user = <User(id=445da761-e32a-455b-bb71-d58344f7679e, email=tester-4948b111-9e2d-463d-bc8c-94daceda62d7@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x12084fb60>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('fef6b3e2-95b5-4c79-b78c-cf58917a8bf1'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_____________________________________________________________ ERROR at setup of TestCallAttemptRepository.test_get_by_call_id _____________________________________________________________
[gw3] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x107837a00>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('6effda01-e983-46ba-bfab-d47a73f74a90'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x107869fa0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x106a18b60>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x107855850>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x107855400>, parameters = [(UUID('6effda01-e983-46ba-bfab-d47a73f74a90'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10694fb60>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106a1a7b0>
test_user = <User(id=7ceb1aa0-270e-4b71-9046-464554911982, email=tester-915c73b2-3c52-49ad-b20b-3f9cf1187818@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10694fb60>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('6effda01-e983-46ba-bfab-d47a73f74a90'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
___________________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_without_provider ___________________________________________________________
[gw1] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x113323820>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('47d530ee-0142-4828-926e-0f64ac6b696b'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x113351dc0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x111f1b8c0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x113331670>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x113331160>, parameters = [(UUID('47d530ee-0142-4828-926e-0f64ac6b696b'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x111e4fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x111f18470>
test_user = <User(id=7f14cada-164a-46bd-9974-db98196edee4, email=tester-7a1f6afe-4230-4873-8cd8-b486c78e2f14@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x111e4fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('47d530ee-0142-4828-926e-0f64ac6b696b'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
__________________________________________________________ ERROR at setup of TestCallAttemptRepository.test_create_call_attempt ___________________________________________________________
[gw2] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1121177c0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('c477e8bb-16f2-4f97-ad3f-798c9517af3c'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1121d9e20>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x11131e900>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1121555e0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x112155190>, parameters = [(UUID('c477e8bb-16f2-4f97-ad3f-798c9517af3c'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x11124fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x11131ed80>
test_user = <User(id=b524cb7d-f6de-4938-b4bb-540b2844ec77, email=tester-5ac4da30-83a6-4376-909a-08fd4c4d3de4@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x11124fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('c477e8bb-16f2-4f97-ad3f-798c9517af3c'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_____________________________________________________________ ERROR at setup of TestCallAttemptRepository.test_get_by_contact _____________________________________________________________
[gw5] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x108113be0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('6b123695-d3ca-4a49-95f5-b85092dabec5'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1081dba10>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x107318b30>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x108155730>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x108155280>, parameters = [(UUID('6b123695-d3ca-4a49-95f5-b85092dabec5'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10724fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10731bf80>
test_user = <User(id=d0287e43-b173-4359-bc22-372a0e944531, email=tester-74ea30dd-9d8d-41d0-8000-ad6579611239@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10724fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('6b123695-d3ca-4a49-95f5-b85092dabec5'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_______________________________________________________ ERROR at setup of TestCallScheduler.test_scheduler_increments_attempt_count _______________________________________________________
[gw0] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1058e35e0>
operation = 'SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.camp...call_attempts.updated_at AS call_attempts_updated_at \nFROM call_attempts \nWHERE $1::UUID = call_attempts.campaign_id'
parameters = (UUID('9e9b4b79-cbf1-4496-be61-788c9add13e4'),)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: in _prepare
    prepared_stmt = await self._connection.prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:638: in prepare
    return await self._prepare(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:657: in _prepare
    stmt = await self._get_statement(
.venv/lib/python3.12/site-packages/asyncpg/connection.py:443: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UndefinedColumnError: column call_attempts.created_at does not exist

asyncpg/protocol/protocol.pyx:165: UndefinedColumnError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x1058c4470>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x104a18c20>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1058958b0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x105895460>, parameters = [(UUID('9e9b4b79-cbf1-4496-be61-788c9add13e4'),)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10494fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x104a18e90>
test_user = <User(id=98b0f5ff-a37a-49a3-80e6-906c0d3fc65f, email=tester-4965662d-18c5-46c2-84a2-21e79ccb9575@example.com, role=viewer)>

    @pytest_asyncio.fixture
    async def running_campaign(db_session: AsyncSession, test_user: User) -> Campaign:
        """Create a running campaign for testing."""
        campaign = Campaign(
            id=uuid4(),
            name="Test Campaign",
            description="Test campaign for scheduler",
            status=CampaignStatus.RUNNING,
            language=CampaignLanguage.EN,
            intro_script="Hello, this is a test survey.",
            question_1_text="How satisfied are you?",
            question_1_type=QuestionType.SCALE,
            question_2_text="Any feedback?",
            question_2_type=QuestionType.FREE_TEXT,
            question_3_text="Would you recommend us?",
            question_3_type=QuestionType.SCALE,
            max_attempts=3,
            retry_interval_minutes=60,
            allowed_call_start_local=time(0, 0),  # Allow all times for testing
            allowed_call_end_local=time(23, 59),
            created_by_user_id=test_user.id,
        )
        db_session.add(campaign)
        await db_session.commit()
>       await db_session.refresh(campaign)

runs/kit/REQ-008/test/test_scheduler.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/session.py:329: in refresh
    await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:3154: in refresh
    loading.load_on_ident(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:510: in load_on_ident
    return load_on_pk_identity(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:706: in load_on_pk_identity
    return result.one()
           ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1815: in one
    return self._only_one_row(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:757: in _only_one_row
    row: Optional[_InterimRowType[Any]] = onerow(hard_close=True)
                                          ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:1678: in _fetchone_impl
    return self._real_result._fetchone_impl(hard_close=hard_close)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/result.py:2264: in _fetchone_impl
    row = next(self.iterator, _NO_ROW)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:247: in chunks
    post_load.invoke(context, path)
.venv/lib/python3.12/site-packages/sqlalchemy/orm/loading.py:1564: in invoke
    loader(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1447: in _load_for_path
    value = lazyloader._load_for_state(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
.venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10494fc50>>, error = UndefinedColumnError('column call_attempts.created_at does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not exist
E                   [SQL: SELECT call_attempts.id AS call_attempts_id, call_attempts.contact_id AS call_attempts_contact_id, call_attempts.campaign_id AS call_attempts_campaign_id, call_attempts.attempt_number AS call_attempts_attempt_number, call_attempts.call_id AS call_attempts_call_id, call_attempts.provider_call_id AS call_attempts_provider_call_id, call_attempts.started_at AS call_attempts_started_at, call_attempts.ended_at AS call_attempts_ended_at, call_attempts.outcome AS call_attempts_outcome, call_attempts.created_at AS call_attempts_created_at, call_attempts.updated_at AS call_attempts_updated_at
E                   FROM call_attempts
E                   WHERE $1::UUID = call_attempts.campaign_id]
E                   [parameters: (UUID('9e9b4b79-cbf1-4496-be61-788c9add13e4'),)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
_________________________________________________________ ERROR at teardown of TestCallAttemptRepository.test_create_call_attempt _________________________________________________________
[gw2] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x1113686a0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x11131ef60>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x11131e900>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1121d81a0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1121d80e0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x11124fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x11124fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
___________________________________________________________ ERROR at teardown of TestCallAttemptRepository.test_update_outcome ____________________________________________________________
[gw4] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x120970820>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x12091fe00>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x12091fc20>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1217c84a0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1217c8410>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x12084fb60>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x12084fb60>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_____________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_increments_attempt_count ______________________________________________________
[gw0] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x105410400>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x104a1a120>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x104a18c20>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1058c4260>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1058c4380>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10494fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10494fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
___________________________________________________________ ERROR at teardown of TestCallAttemptRepository.test_get_by_call_id ____________________________________________________________
[gw3] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x106a68880>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x106a19bb0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x106a18b60>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x107868470>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x107868440>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10694fb60>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10694fb60>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
_________________________________________________________ ERROR at teardown of TestCallScheduler.test_scheduler_without_provider __________________________________________________________
[gw1] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x111f74700>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x111f19dc0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x111f1b8c0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x113350fe0>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1133501a0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x111e4fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x111e4fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
___________________________________________________________ ERROR at teardown of TestCallAttemptRepository.test_get_by_contact ____________________________________________________________
[gw5] darwin -- Python 3.12.0 /Users/a.franco/dev/authenticfake/VoiceSurveyAgent/.venv/bin/python3.12

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x107368ac0>, operation = '\nDROP TABLE call_attempts', parameters = ()

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection

        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()

            if parameters is None:
                parameters = ()

            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None

                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:550:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:177: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:268: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv/lib/python3.12/site-packages/asyncpg/prepared_stmt.py:257: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.DependentObjectsStillExistError: cannot drop table call_attempts because other objects depend on it
E   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

asyncpg/protocol/protocol.pyx:205: DependentObjectsStillExistError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x10731a9f0>, dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x107318b30>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x1081d8380>, statement = <sqlalchemy.dialects.postgresql.base.PGDDLCompiler object at 0x1081d82f0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.

        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()

            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )

        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )

        effective_parameters: Optional[_AnyExecuteParams]

        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters

        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )

        if self._echo:
            self._log_info(str_statement)

            stats = context._get_cache_stats()

            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )

        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10724fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.Error: <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: Error

The above exception was the direct cause of the following exception:

    def finalizer() -> None:
        """Yield again, to finalize."""

        async def async_finalizer() -> None:
            try:
                await gen_obj.__anext__()
            except StopAsyncIteration:
                pass
            else:
                msg = "Async generator fixture didn't stop."
                msg += "Yield only once."
                raise ValueError(msg)

>       runner.run(async_finalizer(), context=context)

.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:330:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/base_events.py:664: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/pytest_asyncio/plugin.py:322: in async_finalizer
    await gen_obj.__anext__()
runs/kit/REQ-008/test/conftest.py:22: in async_engine
    await conn.run_sync(Base.metadata.drop_all)
.venv/lib/python3.12/site-packages/sqlalchemy/ext/asyncio/engine.py:888: in run_sync
    return await greenlet_spawn(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5956: in drop_all
    bind._run_ddl_visitor(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1142: in visit_metadata
    self.traverse_single(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:1209: in visit_table
    DropTable(table)._invoke_with(self.connection)
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1419: in execute
    return meth(
.venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1530: in _execute_ddl
    ret = self._execute_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:952: in do_execute
    cursor.execute(statement, parameters)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x10724fc50>>
error = DependentObjectsStillExistError('cannot drop table call_attempts because other objects depend on it')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False

        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate

            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other objects depend on it
E                   DETAIL:  constraint survey_responses_call_attempt_id_fkey on table survey_responses depends on table call_attempts
E                   constraint events_call_attempt_id_fkey on table events depends on table call_attempts
E                   constraint transcript_snippets_call_attempt_id_fkey on table transcript_snippets depends on table call_attempts
E                   HINT:  Use DROP ... CASCADE to drop the dependent objects too.
E                   [SQL:
E                   DROP TABLE call_attempts]
E                   (Background on this error at: https://sqlalche.me/e/20/dbapi)

.venv/lib/python3.12/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: DBAPIError
================================================================================= short test summary info =================================================================================
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_selects_pending_contacts - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_creates_call_attempt_record - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_updates_contact_state_to_in_progress - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_selects_not_reached_contacts - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_excludes_do_not_call_contacts - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_skips_outside_call_window - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_handles_provider_failure - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_respects_max_concurrent_calls - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_excludes_max_attempts_contacts - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_skips_paused_campaigns - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_creates_call_attempt_record - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_selects_not_reached_contacts - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_respects_max_concurrent_calls - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_updates_contact_state_to_in_progress - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_selects_pending_contacts - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_skips_outside_call_window - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_handles_provider_failure - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_excludes_do_not_call_contacts - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_skips_paused_campaigns - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_excludes_max_attempts_contacts - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_update_outcome - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_get_by_call_id - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_without_provider - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_create_call_attempt - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_get_by_contact - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_increments_attempt_count - sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedColumnError'>: column call_attempts.created_at does not...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_create_call_attempt - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_update_outcome - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_increments_attempt_count - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_get_by_call_id - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallScheduler::test_scheduler_without_provider - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
ERROR runs/kit/REQ-008/test/test_scheduler.py::TestCallAttemptRepository::test_get_by_contact - sqlalchemy.exc.DBAPIError: (sqlalchemy.dialects.postgresql.asyncpg.Error) <class 'asyncpg.exceptions.DependentObjectsStillExistError'>: cannot drop table call_attempts because other ...
32 errors in 4.18s
(.venv) a.f